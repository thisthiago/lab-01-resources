{"paragraphs":[{"text":"%md\r\n# Entendendo Joins em PySpark e Escrita de Dados\r\n\r\n## O que são Joins?\r\n\r\n**Joins** são operações que permitem combinar linhas de dois ou mais DataFrames com base em uma coluna em comum — normalmente chamada de **chave**.\r\n\r\nNo PySpark, os joins funcionam como em SQL, com vários tipos disponíveis:\r\n\r\n| Tipo de Join     | Descrição |\r\n|------------------|-----------|\r\n| `inner`          | Retorna apenas os registros que possuem correspondência em ambos os DataFrames. |\r\n| `left` (left outer)  | Mantém todos os registros do DataFrame da esquerda e adiciona os correspondentes da direita (se existirem). |\r\n| `right` (right outer) | Mantém todos os registros do DataFrame da direita e adiciona os correspondentes da esquerda (se existirem). |\r\n| `outer` (full outer) | Retorna todos os registros, de ambos os DataFrames, preenchendo com `null` onde não houver correspondência. |\r\n\r\n---\r\n\r\n## Dicionário de Dados\r\n\r\n### 📁 Tabela: `users`\r\n\r\n| Coluna                  | Tipo     | Descrição |\r\n|-------------------------|----------|-----------|\r\n| `user_id`               | string   | Identificador único do usuário (chave primária) |\r\n| `platform`              | string   | Plataforma em que o conteúdo foi gerado (Reddit, TikTok, Instagram) |\r\n| `is_hand_edited`        | string   | Indica se a imagem foi editada manualmente (`Yes` ou `No`) |\r\n| `ethical_concerns_flag`| string   | Indica se houve alguma preocupação ética associada à imagem |\r\n\r\n---\r\n\r\n### 🖼️ Tabela: `images`\r\n\r\n| Coluna                  | Tipo     | Descrição |\r\n|-------------------------|----------|-----------|\r\n| `image_id`              | string   | Identificador único da imagem |\r\n| `user_id`               | string   | ID do usuário que criou a imagem (chave estrangeira) |\r\n| `prompt`                | string   | Texto usado para gerar a imagem |\r\n| `likes`                 | int      | Número de curtidas recebidas |\r\n| `shares`                | int      | Número de compartilhamentos |\r\n| `comments`              | int      | Número de comentários |\r\n| `generation_time`       | float    | Tempo (em segundos) para gerar a imagem |\r\n| `gpu_usage`             | int      | Percentual de uso da GPU na geração |\r\n| `file_size_kb`          | int      | Tamanho do arquivo em KB |\r\n| `resolution`            | string   | Resolução da imagem (ex: 1024x1024) |\r\n| `style_accuracy_score` | int      | Score de precisão de estilo com base no prompt |\r\n| `creation_date`         | string   | Data de criação da imagem |\r\n| `top_comment`           | string   | Comentário mais votado na imagem |\r\n\r\n---\r\n\r\n## 🔗 Relacionamento entre as tabelas\r\n\r\nAs tabelas `users` e `images` estão conectadas pela coluna **`user_id`**, que funciona como:\r\n\r\n- `user_id` em `users` → **Chave primária**\r\n- `user_id` em `images` → **Chave estrangeira**\r\n\r\n\r\n---\r\n","user":"anonymous","dateUpdated":"2025-04-15T16:06:03+0000","progress":0,"config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true,"completionSupport":false},"colWidth":12,"fontSize":9,"editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h1>Entendendo Joins em PySpark e Escrita de Dados</h1>\n<h2>O que são Joins?</h2>\n<p><strong>Joins</strong> são operações que permitem combinar linhas de dois ou mais DataFrames com base em uma coluna em comum — normalmente chamada de <strong>chave</strong>.</p>\n<p>No PySpark, os joins funcionam como em SQL, com vários tipos disponíveis:</p>\n<table>\n<thead>\n<tr><th>Tipo de Join</th><th>Descrição</th></tr>\n</thead>\n<tbody>\n<tr><td><code>inner</code></td><td>Retorna apenas os registros que possuem correspondência em ambos os DataFrames.</td></tr>\n<tr><td><code>left</code> (left outer)</td><td>Mantém todos os registros do DataFrame da esquerda e adiciona os correspondentes da direita (se existirem).</td></tr>\n<tr><td><code>right</code> (right outer)</td><td>Mantém todos os registros do DataFrame da direita e adiciona os correspondentes da esquerda (se existirem).</td></tr>\n<tr><td><code>outer</code> (full outer)</td><td>Retorna todos os registros, de ambos os DataFrames, preenchendo com <code>null</code> onde não houver correspondência.</td></tr>\n</tbody>\n</table>\n<hr />\n<h2>Dicionário de Dados</h2>\n<h3>📁 Tabela: <code>users</code></h3>\n<table>\n<thead>\n<tr><th>Coluna</th><th>Tipo</th><th>Descrição</th></tr>\n</thead>\n<tbody>\n<tr><td><code>user_id</code></td><td>string</td><td>Identificador único do usuário (chave primária)</td></tr>\n<tr><td><code>platform</code></td><td>string</td><td>Plataforma em que o conteúdo foi gerado (Reddit, TikTok, Instagram)</td></tr>\n<tr><td><code>is_hand_edited</code></td><td>string</td><td>Indica se a imagem foi editada manualmente (<code>Yes</code> ou <code>No</code>)</td></tr>\n<tr><td><code>ethical_concerns_flag</code></td><td>string</td><td>Indica se houve alguma preocupação ética associada à imagem</td></tr>\n</tbody>\n</table>\n<hr />\n<h3>🖼️ Tabela: <code>images</code></h3>\n<table>\n<thead>\n<tr><th>Coluna</th><th>Tipo</th><th>Descrição</th></tr>\n</thead>\n<tbody>\n<tr><td><code>image_id</code></td><td>string</td><td>Identificador único da imagem</td></tr>\n<tr><td><code>user_id</code></td><td>string</td><td>ID do usuário que criou a imagem (chave estrangeira)</td></tr>\n<tr><td><code>prompt</code></td><td>string</td><td>Texto usado para gerar a imagem</td></tr>\n<tr><td><code>likes</code></td><td>int</td><td>Número de curtidas recebidas</td></tr>\n<tr><td><code>shares</code></td><td>int</td><td>Número de compartilhamentos</td></tr>\n<tr><td><code>comments</code></td><td>int</td><td>Número de comentários</td></tr>\n<tr><td><code>generation_time</code></td><td>float</td><td>Tempo (em segundos) para gerar a imagem</td></tr>\n<tr><td><code>gpu_usage</code></td><td>int</td><td>Percentual de uso da GPU na geração</td></tr>\n<tr><td><code>file_size_kb</code></td><td>int</td><td>Tamanho do arquivo em KB</td></tr>\n<tr><td><code>resolution</code></td><td>string</td><td>Resolução da imagem (ex: 1024x1024)</td></tr>\n<tr><td><code>style_accuracy_score</code></td><td>int</td><td>Score de precisão de estilo com base no prompt</td></tr>\n<tr><td><code>creation_date</code></td><td>string</td><td>Data de criação da imagem</td></tr>\n<tr><td><code>top_comment</code></td><td>string</td><td>Comentário mais votado na imagem</td></tr>\n</tbody>\n</table>\n<hr />\n<h2>🔗 Relacionamento entre as tabelas</h2>\n<p>As tabelas <code>users</code> e <code>images</code> estão conectadas pela coluna <strong><code>user_id</code></strong>, que funciona como:</p>\n<ul>\n<li><code>user_id</code> em <code>users</code> → <strong>Chave primária</strong></li>\n<li><code>user_id</code> em <code>images</code> → <strong>Chave estrangeira</strong></li>\n</ul>\n<hr />\n\n</div>"}]},"apps":[],"runtimeInfos":{},"progressUpdateIntervalMs":500,"jobName":"paragraph_1744731899813_428628442","id":"paragraph_1744731899813_428628442","dateCreated":"2025-04-15T15:44:59+0000","dateStarted":"2025-04-15T16:06:03+0000","dateFinished":"2025-04-15T16:06:03+0000","status":"FINISHED","focus":true},{"title":"Leitura dos arquivos JSON","text":"%pyspark\nimages_df = spark.read.json(\"s3a://bucket-teste/json/images.json\")\nusers_df = spark.read.json(\"s3a://bucket-teste/json/users.json\")","user":"anonymous","dateUpdated":"2025-04-15T15:53:12+0000","progress":0,"config":{"tableHide":true,"editorSetting":{"language":"python","editOnDblClick":false,"completionSupport":true,"completionKey":"TAB"},"colWidth":12,"fontSize":9,"editorHide":false,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[]},"apps":[],"runtimeInfos":{"jobUrl":{"propertyName":"jobUrl","label":"SPARK JOB","tooltip":"View in Spark web UI","group":"spark","values":[{"jobUrl":"http://9382a0befda4:4040/jobs/job?id=133"},{"jobUrl":"http://9382a0befda4:4040/jobs/job?id=133"},{"jobUrl":"http://9382a0befda4:4040/jobs/job?id=133"},{"jobUrl":"http://9382a0befda4:4040/jobs/job?id=133"},{"jobUrl":"http://9382a0befda4:4040/jobs/job?id=133"},{"jobUrl":"http://9382a0befda4:4040/jobs/job?id=134"},{"jobUrl":"http://9382a0befda4:4040/jobs/job?id=134"},{"jobUrl":"http://9382a0befda4:4040/jobs/job?id=134"},{"jobUrl":"http://9382a0befda4:4040/jobs/job?id=134"},{"jobUrl":"http://9382a0befda4:4040/jobs/job?id=134"}],"interpreterSettingId":"spark"}},"progressUpdateIntervalMs":500,"jobName":"paragraph_1744732225862_412435563","id":"paragraph_1744732225862_412435563","dateCreated":"2025-04-15T15:50:25+0000","dateStarted":"2025-04-15T15:52:29+0000","dateFinished":"2025-04-15T15:52:44+0000","status":"FINISHED"},{"title":"Visualização dos esquemas","text":"%pyspark\nimages_df.printSchema()\nusers_df.printSchema()","user":"anonymous","dateUpdated":"2025-04-15T15:53:19+0000","progress":0,"config":{"colWidth":12,"fontSize":9,"title":true,"results":{},"enabled":true,"editorSetting":{"language":"python","editOnDblClick":false,"completionKey":"TAB","completionSupport":true}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"root\n |-- comments: long (nullable = true)\n |-- creation_date: string (nullable = true)\n |-- file_size_kb: long (nullable = true)\n |-- generation_time: double (nullable = true)\n |-- gpu_usage: long (nullable = true)\n |-- image_id: string (nullable = true)\n |-- likes: long (nullable = true)\n |-- prompt: string (nullable = true)\n |-- resolution: string (nullable = true)\n |-- shares: long (nullable = true)\n |-- style_accuracy_score: long (nullable = true)\n |-- top_comment: string (nullable = true)\n |-- user_id: string (nullable = true)\n\nroot\n |-- ethical_concerns_flag: string (nullable = true)\n |-- is_hand_edited: string (nullable = true)\n |-- platform: string (nullable = true)\n |-- user_id: string (nullable = true)\n\n"}]},"apps":[],"runtimeInfos":{},"progressUpdateIntervalMs":500,"jobName":"paragraph_1744732349836_2010966031","id":"paragraph_1744732349836_2010966031","dateCreated":"2025-04-15T15:52:29+0000","dateStarted":"2025-04-15T15:52:48+0000","dateFinished":"2025-04-15T15:52:52+0000","status":"FINISHED"},{"title":"JOIN: inner join entre users e images via user_id","text":"%pyspark\njoined_df = images_df.join(users_df, on=\"user_id\", how=\"inner\")","user":"anonymous","dateUpdated":"2025-04-15T15:53:50+0000","progress":0,"config":{"colWidth":12,"fontSize":9,"title":true,"results":{},"enabled":true,"editorSetting":{"language":"python","editOnDblClick":false,"completionKey":"TAB","completionSupport":true}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[]},"apps":[],"runtimeInfos":{},"progressUpdateIntervalMs":500,"jobName":"paragraph_1744732368335_268399928","id":"paragraph_1744732368335_268399928","dateCreated":"2025-04-15T15:52:48+0000","dateStarted":"2025-04-15T15:53:50+0000","dateFinished":"2025-04-15T15:53:53+0000","status":"FINISHED"},{"text":"%pyspark\njoined_df.select(\"user_id\", \"platform\", \"prompt\", \"likes\", \"is_hand_edited\").show(5, truncate=False)","user":"anonymous","dateUpdated":"2025-04-15T15:53:56+0000","progress":0,"config":{"colWidth":12,"fontSize":9,"results":{},"enabled":true,"editorSetting":{"language":"python","editOnDblClick":false,"completionKey":"TAB","completionSupport":true}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"+--------+---------+--------------------------------------------+-----+--------------+\n|user_id |platform |prompt                                      |likes|is_hand_edited|\n+--------+---------+--------------------------------------------+-----+--------------+\n|6a7adf3d|Reddit   |Studio Ghibli-inspired ocean with giant fish|916  |Yes           |\n|523b8706|Reddit   |Ghibli-style village at sunset              |2965 |Yes           |\n|0e02592a|Instagram|A lone traveler exploring an enchanted ruin |4727 |No            |\n|9ed78a42|TikTok   |Spirited Away-style bustling market street  |1629 |No            |\n|69ec8f02|TikTok   |Magical Ghibli forest with floating lanterns|2573 |No            |\n+--------+---------+--------------------------------------------+-----+--------------+\nonly showing top 5 rows\n\n"}]},"apps":[],"runtimeInfos":{"jobUrl":{"propertyName":"jobUrl","label":"SPARK JOB","tooltip":"View in Spark web UI","group":"spark","values":[{"jobUrl":"http://9382a0befda4:4040/jobs/job?id=136"},{"jobUrl":"http://9382a0befda4:4040/jobs/job?id=136"},{"jobUrl":"http://9382a0befda4:4040/jobs/job?id=136"},{"jobUrl":"http://9382a0befda4:4040/jobs/job?id=136"},{"jobUrl":"http://9382a0befda4:4040/jobs/job?id=136"}],"interpreterSettingId":"spark"}},"progressUpdateIntervalMs":500,"jobName":"paragraph_1744732417425_1894511150","id":"paragraph_1744732417425_1894511150","dateCreated":"2025-04-15T15:53:37+0000","dateStarted":"2025-04-15T15:53:56+0000","dateFinished":"2025-04-15T15:53:59+0000","status":"FINISHED"},{"title":"Salvar os resultados como JSON","text":"%pyspark\njoined_df.write.mode(\"overwrite\").json(\"s3a://bucket-teste/Generated_Ghibli_Trend\")","user":"anonymous","dateUpdated":"2025-04-15T15:57:25+0000","progress":0,"config":{"editorSetting":{"language":"python","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"colWidth":12,"fontSize":9,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[]},"apps":[],"runtimeInfos":{"jobUrl":{"propertyName":"jobUrl","label":"SPARK JOB","tooltip":"View in Spark web UI","group":"spark","values":[{"jobUrl":"http://9382a0befda4:4040/jobs/job?id=142"},{"jobUrl":"http://9382a0befda4:4040/jobs/job?id=142"},{"jobUrl":"http://9382a0befda4:4040/jobs/job?id=142"},{"jobUrl":"http://9382a0befda4:4040/jobs/job?id=142"},{"jobUrl":"http://9382a0befda4:4040/jobs/job?id=142"}],"interpreterSettingId":"spark"}},"progressUpdateIntervalMs":500,"jobName":"paragraph_1744732421608_781316101","id":"paragraph_1744732421608_781316101","dateCreated":"2025-04-15T15:53:41+0000","dateStarted":"2025-04-15T15:57:25+0000","dateFinished":"2025-04-15T15:57:31+0000","status":"FINISHED"},{"text":"%md\n## Modos de Escrita no PySpark (`DataFrame.write.mode()`)\n\n| Modo        | Descrição                                                                 |\n|-------------|--------------------------------------------------------------------------|\n| `append`    | Adiciona os dados ao diretório de destino, sem apagar o que já existe.  |\n| `overwrite` | Sobrescreve todo o conteúdo existente no destino com os novos dados.     |\n| `ignore`    | Não escreve nada **se os dados já existirem** (ignora a operação).       |\n| `error` ou `errorifexists` | Gera um erro **se os dados já existirem** (modo padrão).     |\n\n> 💡 Dica: Use `overwrite` com cuidado! Ele apaga tudo no destino antes de gravar.\n","user":"anonymous","dateUpdated":"2025-04-15T15:59:06+0000","progress":0,"config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true,"completionKey":"TAB","completionSupport":false},"colWidth":12,"fontSize":9,"editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h2>Modos de Escrita no PySpark (<code>DataFrame.write.mode()</code>)</h2>\n<table>\n<thead>\n<tr><th>Modo</th><th>Descrição</th></tr>\n</thead>\n<tbody>\n<tr><td><code>append</code></td><td>Adiciona os dados ao diretório de destino, sem apagar o que já existe.</td></tr>\n<tr><td><code>overwrite</code></td><td>Sobrescreve todo o conteúdo existente no destino com os novos dados.</td></tr>\n<tr><td><code>ignore</code></td><td>Não escreve nada <strong>se os dados já existirem</strong> (ignora a operação).</td></tr>\n<tr><td><code>error</code> ou <code>errorifexists</code></td><td>Gera um erro <strong>se os dados já existirem</strong> (modo padrão).</td></tr>\n</tbody>\n</table>\n<blockquote>\n<p>💡 Dica: Use <code>overwrite</code> com cuidado! Ele apaga tudo no destino antes de gravar.</p>\n</blockquote>\n\n</div>"}]},"apps":[],"runtimeInfos":{},"progressUpdateIntervalMs":500,"jobName":"paragraph_1744732546601_609628438","id":"paragraph_1744732546601_609628438","dateCreated":"2025-04-15T15:55:46+0000","dateStarted":"2025-04-15T15:59:06+0000","dateFinished":"2025-04-15T15:59:06+0000","status":"FINISHED"},{"text":"%md\n","user":"anonymous","dateUpdated":"2025-04-15T15:59:06+0000","progress":0,"config":{"colWidth":12,"fontSize":9,"enabled":true,"results":{},"editorSetting":{"language":"markdown","editOnDblClick":true,"completionSupport":false}},"settings":{"params":{},"forms":{}},"apps":[],"runtimeInfos":{},"progressUpdateIntervalMs":500,"jobName":"paragraph_1744732746688_221169952","id":"paragraph_1744732746688_221169952","dateCreated":"2025-04-15T15:59:06+0000","status":"READY"}],"name":"05 - Joins entre Dataframes e Escrita","id":"2KSF1DJDN","defaultInterpreterGroup":"spark","version":"0.12.0","noteParams":{},"noteForms":{},"angularObjects":{},"config":{"isZeppelinNotebookCronEnable":false,"looknfeel":"default","personalizedMode":"false"},"info":{},"path":"/05 - Joins entre Dataframes e Escrita"}